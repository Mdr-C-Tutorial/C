# OJ 10705 - 向量夹角计算

## 题目描述

输入维数 n（2 ≤ n ≤ 100），再输入两个 n 维向量在某直角坐标系内的坐标，输出它们的夹角。

## 输入格式

第 1 行，输入一个整数 n，代表维数。

第 2 行，输入 n 个整数，代表第一个向量的坐标。

第 3 行，输入 n 个整数，代表第二个向量的坐标。

## 输出格式

输出一行，为两向量的夹角（角度而非弧度），保留两位小数。

## 解析

令 $\vec{a}=(a_1,a_2,...,a_n), \vec{b}=(b_1,b_2,...,b_n)$，那么：

$$\cos\theta=\frac{\vec{a}\cdot\vec{b}}{|\vec{a}|\cdot|\vec{b}|}$$

其中：

$$\vec{a}\cdot\vec{b}=\sum_{i=1}^n a_ib_i,|\vec{a}|=\sqrt{\sum_{i=1}^{n}a_i^2},|\vec{b}|=\sqrt{\sum_{i=1}^{n}b_i^2}$$

弧度转角度：除以 180，再乘以圆周率。

## 答案

```c
#include <stdio.h>
#include <math.h>

#define MAX_DIM 100

// 判断是否为零向量
int is_zero_vector(const double v[], int n) {
    for (int i = 0; i < n; i++) {
        if (fabs(v[i]) > 1e-10) return 0;  // 使用小阈值判断是否为 0
    }
    return 1;
}

double dot_product(const double a[], const double b[], int n) {
    double sum = 0;
    for (int i = 0; i < n; i++) {
        sum += a[i] * b[i];
    }
    return sum;
}

double vector_length(const double v[], int n) {
    return sqrt(dot_product(v, v, n));
}

int main(void) {
    int n;
    double v1[MAX_DIM], v2[MAX_DIM];

    scanf("%d", &n);

    if (n < 2 || n > MAX_DIM) {
        return 1;
    }

    for (int i = 0; i < n; i++) {
        scanf("%lf", &v1[i]);
    }

    for (int i = 0; i < n; i++) {
        scanf("%lf", &v2[i]);
    }

    if (is_zero_vector(v1, n) || is_zero_vector(v2, n)) {
        return 1;
    }

    double cos_theta = dot_product(v1, v2, n) /
                      (vector_length(v1, n) * vector_length(v2, n));

    if (cos_theta > 1) cos_theta = 1;
    if (cos_theta < -1) cos_theta = -1;

    double angle = acos(cos_theta) * 180.0 / M_PI;

    printf("%.2f\n", angle);

    return 0;
}
```

## 测试数据

```txt
# 测试点 1
输入：
2
1 0
0 1
输出：
90.00

# 测试点 2
输入：
3
1 1 1
1 1 1
输出：
0.00

# 测试点 3
输入：
4
1 0 0 0
-1 0 0 0
输出：
180.00

# 测试点 4
输入：
5
1 1 1 1 1
1 0 0 0 -1
输出：
90.00

# 测试点 5
输入：
10
1 2 3 4 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
输出：
14.42

# 测试点 6
输入：
20
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1
输出：
90.00

# 测试点 7
输入：
50
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
输出：
90.00

# 测试点 8
输入：
100
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
输出：
180.00

# 测试点 9
输入：
3
0.5 0.5 0.7071067811865476
0.5 0.5 -0.7071067811865476
输出：
90.00

# 测试点 10
输入：
4
0.5773502691896258 0.5773502691896258 0.5773502691896258 0
0.5 0.5 0.5 0.5
输出：
19.47
```
