# MdrOS 项目概述

开发操作系统是一个漫长的过程，需要你有一定的计算机底层原理知识以及 C 和汇编语言的基础。
本章教程将教学您如何开发一个 x86 平台的操作系统

> 该教程有很多不详细之处，并不能直接作为保姆式教程使用
>
> - 实际上该项目为参考式项目，提供了一个大致的开发方向，以及标注了很多开发中可能遇到的问题

## 概念

操作系统是一种系统软件，它是控制管理计算机系统的硬软件，分配调度资源的管理者\
其内部功能有：

- 内存管理
- 设备驱动
- 中断处理
- 任务调度
- 文件管理
- 网络处理

> 还有很多，此处不一一列举

### 计算机启动过程

1. 电源键按下
2. POST 加电硬件自检
3. 加载 BIOS
4. 加载引导程序
5. 计算机控制权移交给操作系统内核

这样，一个操作系统就算启动了。接下来内核会初始化各种功能以及加载一些必要的设备驱动，具体的启动方式还是要依据该操作系统的架构决定。

## 环境准备

您需要：

- [xmake](https://xmake.io) 构建工具
- Clang/zig_cc C 语言编译器 (xmake 自动下载)
- [nasm](https://nasm.us/) 汇编编译器

## 项目结构

在教程中标注的一些函数中，注释会解释该函数原本被定义在哪个源文件内，为了方便理解而写入代码示例中。

我们建议你安排好你的项目结构，以便这些函数的重复利用。

## 相关文献网站

在开发操作系统的细节部分 (如某些硬盘系统的接口协议) 您可以查阅相关资料。

> 养成经常查阅资料的好习惯是个不错的选择

- [OSDEV](https://wiki.osdev.org/) 该 Wiki 讲解了所有有关操作系统开发的知识细节
- [CSDN](https://blog.csdn.net/) 可以查找到更多前辈们的开发经验
- [Intel 文档](https://www.intel.cn/content/www/cn/zh/resources-documentation/developer.html) 关于 Intel 硬件平台的详细硬件开发细节，
  您可以在这里查阅

## 教程目录

1. [**项目构建**](/教程/正文/项目/MdrOS/build.md)
2. [**引导程序**](/教程/正文/项目/MdrOS/bootloader.md)
3. [**视频驱动**](/教程/正文/项目/MdrOS/video_driver.md)
4. [**中断系统**](/教程/正文/项目/MdrOS/interrupt.md)
5. [**内存管理**](/教程/正文/项目/MdrOS/memory.md)
6. [**文件系统**](/教程/正文/项目/MdrOS/filesystem.md)
7. [**多任务**](/教程/正文/项目/MdrOS/task.md)

番外

- [**ACPI**](/教程/正文/项目/MdrOS/acpi.md)
- [**PCI**](/教程/正文/项目/MdrOS/pci.md)
- [**OSDEV 代码校正**](/教程/正文/项目/MdrOS/osdev.md)

## 告诫

- GUI 并不是操作系统必要的功能，一个操作系统可以没有 GUI, 但是其必要实现的功能必须齐全且稳定
- 《30 天自制操作系统》这本书仅供 GUI 部分参考，其他功能实现并不是很好，不建议您全部借鉴
- 64 位长的操作系统会比 32 位保护模式的操作系统实现更难，比如 32 位只需要二级页表即可，64 位需要 4 级甚至更多才能管理所有内存
- ARM 等其他架构的 CPU 与 x86 平台的 CPU 实现截然不同，其中 x86 的很多机制在 ARM 是没有的，同理 ARM 某些机制 x86 也没有
- 本教程只是给予开发的一个大致方向与常见问题解答，注意事项提醒等
- 操作系统编写好都是要在实体机上测试的，无法在实体机上跑的操作系统就不是一个真正的操作系统

## 注意事项

::: warning

笔者结合开发过程中发现的实际 BUG，对新手 OS 开发者进行一个警醒作用，避免重复犯同样的错误

:::

> 4Kib: 可以用十进制 `4096` 表示，也可以用十六进制 `0x1000` 表示

### 内存

- cr3 指向的页表基址，必须进行 `4k` 对齐
- 物理内存管理分配出来的页框基址，必须是 `4k` 对齐的再写入页
- `rsp` 的栈基址最好为 16 字节对齐，因为部分实体机机型对此有要求
- 对于物理页框分配器，在使用提供一个初始页表的引导器操作系统开发中 (如 Limine), 需要额外注意内核本身与页表本身的内存占用，否则容易覆写
- 页表本身需要在物理内存上具有连续性，且基址必须 4k 对齐
- 页映射释放后需执行一遍 `TLB` 快表刷新操作，防止缓存干扰映射规则

### 驱动

- 所有设备驱动需要往 `MMIO` 设备寄存器传入物理地址 (设备控制器没有 MMU, 传入虚拟地址无法处理)
- 设备 IRQ 中断请求必须要向中断控制器发送 `EOI` 代表请求处理完毕，不然下一次设备请求不会再次发送
- `PS/2` 键盘需要在你获取了扫描码后才会发送下一次中断，否则 `PS/2` 控制器会阻塞
- `PS/2` 设备中断处理需要在最后发送 `EOI`, 否则多个扫描码发送会造成中断嵌套

### CPU

- `qemu` `VMware` 虚拟机对 `wrfsbase` `rdgsbase` 等扩展指令支持性较差，建议使用 `msr` 对 `fs` `gs` 段寄存器进行操作
- 部分实体机的机型对 `cpuid` 指令的实现有些许差异，编写多核 CPU 初始化等代码时候需要用 `ACPI` 或 `lapic_id` 获取核心的代号，不要用 `cpuid` 指令获取
- 特殊的扩展指令 (如 syscall) 需要特别设置控制寄存器或 `MSR`去启用，且多核环境下需要为每一个核心都执行一遍启用操作
- 内核中不要滥用 `pause` `hlt` 等指令，这些指令会造成 CPU 功耗、频率降低，从而影响性能。

### 并发 / 异步

- 锁不要滥用，否则会发生死锁
- 调度器时钟频率不要太高，否则调度器本身未执行完毕会再一次进入调度器造成中断嵌套
- 异步冲突临界区必须加锁，否则会造成资源竞争冲突

### 开发

- 编译器最好开一下严格模式，因为操作系统本身是非常不好调试的，而且 BUG 溯源极其困难，一个小小的错误会让你头疼一个星期甚至一个月
- 详见 [编程交流生存指南](/杂项/技术无关/1_编程交流群生存指南.md) 第 1 标题，第 40,41,43 条
- 作为内核，你永远要以最坏的情况去针对用户态程序，用户 `syscall` 传来的参数要严格检查是否是空指针以及地址合法性
- 对于内核中对参数有要求的接口，要对参数打好断言，这样可以在自己犯傻后可以快速找出问题

> 你要清楚自己写的是什么，有哪些不足，应该如何安排项目结构
