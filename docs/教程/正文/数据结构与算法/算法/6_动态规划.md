# 动态规划

动态规划（Dynamic Programming, DP）解决的问题通常有两个共性：同一子问题会被重复求解，且原问题的最优解可以由子问题的最优解组合出来。它的核心不是“背公式”，而是把问题拆成一组有顺序、可复用的状态对象，并把“如何从已知状态推到下一个状态”写成稳定的转移关系。只要状态定义正确、边界条件完整，代码就会自然地收敛到正确答案。

## 1. 什么时候该考虑动态规划

如果一个问题在直接递归时出现明显的重叠子问题，例如同一段区间、同一对下标、同一剩余容量被反复访问，那么它就非常适合改写成动态规划。另一个常见信号是“最优子结构”：当前最优结果可以由更小规模问题的最优结果拼接而来。比如最长公共子序列、背包、编辑距离都满足这个条件；而某些需要全局历史且无法压缩到有限状态的信息，就不适合用 DP 直接建模。

## 2. 状态、转移、边界

动态规划的主线可以写成一句话：先定义状态，再定义转移，最后补全边界。状态是一个“描述局部进度的对象”，它必须足够表达后续决策所需的信息，又不能把无关细节也带上；转移是状态之间的有向关系，通常体现为 `max/min/+` 之类的组合；边界是递推的起点，它决定了整张 DP 表是否能被正确填满。很多错误都来自边界漏写或下标语义前后不一致，因此在落代码前把状态含义写成一句自然语言，通常能显著减少返工。

## 3. 两种实现路径

记忆化搜索和自底向上填表本质上是同一组转移关系的两种执行顺序。记忆化搜索更贴近数学递归，代码短、推导直观；自底向上更容易做空间压缩，也更可控。一般可以先写记忆化版本验证状态定义，再改成迭代版本追求性能。这样做可以把“正确性”和“效率”分开处理，定位问题会更清晰。

## 4. 示例一：斐波那契的记忆化搜索

下面这段代码故意选择了最小模型：它只展示“重叠子问题如何通过缓存消除重复计算”。`memo[n]` 的语义是“第 `n` 项的值，若为 `-1` 则表示尚未计算”。

```c
#include <stdio.h>

enum { MAX_N = 93 };

static long long memo[MAX_N + 1];

static void init_memo(void) {
    for (int i = 0; i <= MAX_N; ++i) {
        memo[i] = -1;
    }
}

static long long fib(int n) {
    if (n <= 1) {
        return n;
    }
    if (memo[n] != -1) {
        return memo[n];
    }
    memo[n] = fib(n - 1) + fib(n - 2);
    return memo[n];
}

int main(void) {
    init_memo();
    int n = 50;
    printf("fib(%d) = %lld\n", n, fib(n));
    return 0;
}
```

可能的输出（示例）：

<TerminalWindow>

fib(50) = 12586269025

</TerminalWindow>

## 5. 示例二：0/1 背包的自底向上写法

0/1 背包是最典型的“选或不选”模型。设 `dp[i][c]` 表示“只看前 `i` 件物品，容量上限为 `c` 时能达到的最大价值”。当第 `i` 件物品重量超过 `c` 时只能不选；否则在“选”和“不选”之间取较大值。这个定义的优势是语义非常稳定，后续无论做一维压缩还是路径恢复，都能保持一致。

```c
#include <stdio.h>

enum { N = 4, CAP = 8 };

int main(void) {
    int w[N + 1] = {0, 2, 3, 4, 5};
    int v[N + 1] = {0, 3, 4, 5, 8};
    int dp[N + 1][CAP + 1] = {0};

    for (int i = 1; i <= N; ++i) {
        for (int c = 0; c <= CAP; ++c) {
            dp[i][c] = dp[i - 1][c];
            if (c >= w[i]) {
                int cand = dp[i - 1][c - w[i]] + v[i];
                if (cand > dp[i][c]) {
                    dp[i][c] = cand;
                }
            }
        }
    }

    printf("max_value = %d\n", dp[N][CAP]);
    return 0;
}
```

可能的输出（示例）：

<TerminalWindow>

max_value = 12

</TerminalWindow>

## 6. 示例三：最长公共子序列（LCS）长度与回溯

LCS 的状态常定义为 `dp[i][j]`，表示 `a` 的前 `i` 个字符与 `b` 的前 `j` 个字符的 LCS 长度。如果 `a[i-1] == b[j-1]`，就来自左上角再加一；否则来自上方和左方的较大者。填表完成后，从右下角逆向回溯即可恢复一条实际公共子序列。这类“先求值，再逆向恢复解”的模式在动态规划中非常常见。

```c
#include <stdio.h>
#include <string.h>

enum { MAX_LEN = 64 };

int main(void) {
    const char *a = "ABCBDAB";
    const char *b = "BDCABA";
    int n = (int)strlen(a);
    int m = (int)strlen(b);
    int dp[MAX_LEN][MAX_LEN] = {0};

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (a[i - 1] == b[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = dp[i - 1][j] > dp[i][j - 1] ? dp[i - 1][j] : dp[i][j - 1];
            }
        }
    }

    char out[MAX_LEN] = {0};
    int k = dp[n][m];
    out[k] = '\0';
    int i = n;
    int j = m;
    while (i > 0 && j > 0) {
        if (a[i - 1] == b[j - 1]) {
            out[--k] = a[i - 1];
            --i;
            --j;
        } else if (dp[i - 1][j] >= dp[i][j - 1]) {
            --i;
        } else {
            --j;
        }
    }

    printf("lcs_len = %d\n", dp[n][m]);
    printf("lcs = %s\n", out);
    return 0;
}
```

可能的输出（示例）：

<TerminalWindow>

lcs_len = 4
lcs = BCBA

</TerminalWindow>

## 7. 常见优化：空间压缩

当 `dp[i][*]` 只依赖上一行时，可以把二维表压缩成一维数组，显著降低空间占用。以 0/1 背包为例，容量循环必须从大到小更新，这样 `dp[c - w[i]]` 读取到的仍是“上一轮物品”的结果；若从小到大更新，会把同一物品重复使用，语义就变成了完全背包。这个细节看似微小，但会直接改变问题类型。

```c
for (int i = 1; i <= n; ++i) {
    for (int c = cap; c >= w[i]; --c) {
        int cand = dp[c - w[i]] + v[i];
        if (cand > dp[c]) {
            dp[c] = cand;
        }
    }
}
```

运行结果：该代码块主要用于展示状态更新顺序，单独运行通常无终端输出。

## 8. 写 DP 代码时最容易出错的点

最常见的问题不是转移公式本身，而是状态语义漂移：前半段代码把 `dp[i][j]` 当“前缀”，后半段又当“下标本身”，结果边界和转移互相冲突。另一个高频错误是初值遗漏，尤其是“不可达状态”没有用清晰哨兵值区分，导致后续 `max/min` 把非法路径也混进来了。解决这类问题的办法通常很直接：先写一句完整语义，再对照语义检查每个循环边界是否一致，最后用最小样例手推一遍表格，确认每个格子的来源都可解释。

## 9. 习题

1. n 个人围成圈顺时针报数，报偶数的人出列（不参与后续报数），求最后剩下的人的编号。
2. 在 **_1._** 的基础上，改为报 k 的倍数的人出列。
