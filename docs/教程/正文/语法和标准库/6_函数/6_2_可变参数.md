# 可变参数

可变参数函数允许形参个数在调用时变化，典型例子是 `printf`。这类函数的核心在 `<stdarg.h>`：`va_list`、`va_start`、`va_arg`、`va_end`（以及 `va_copy`）。

## 1. 约束与设计要点

可变参数部分不会携带自动类型信息，函数本身无法“猜出”每个实参的真实类型和数量。因此你必须显式提供协议，例如“第一个形参给出数量”或“使用格式字符串描述类型”。没有协议的可变参数接口几乎必然不可维护。

## 2. 一个安全的最小模式

```c
#include <stdarg.h>
#include <stddef.h>

long long sum_ints(size_t count, ...) {
    va_list ap;
    long long total = 0;

    va_start(ap, count);
    for (size_t i = 0; i < count; ++i) {
        total += va_arg(ap, int);
    }
    va_end(ap);

    return total;
}
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


该函数把 `count` 作为协议字段，调用方与被调方都能确定读取边界。

## 3. 默认实参提升

在可变参数部分，`float` 会提升为 `double`，较窄整数类型会提升为 `int` 或 `unsigned int`。因此 `va_arg` 取值类型必须与提升后类型一致，否则行为未定义。

## 4. 实践建议

能用普通接口表达时，不要为了“灵活”而使用可变参数。只有当调用形态确实需要开放参数个数，且协议可以被静态检查或清楚文档化时，可变参数才是好选择。

## 5. `va_copy` 的使用场景

当同一组可变实参需要被遍历不止一次时，应使用 `va_copy` 复制实参游标。直接重复读取同一个 `va_list` 会导致未定义行为。

```c
#include <stdarg.h>

int consume_twice(int n, ...) {
    va_list ap;
    va_list ap2;

    va_start(ap, n);
    va_copy(ap2, ap);

    /* 第一次读取 ap ... */
    /* 第二次读取 ap2 ... */

    va_end(ap2);
    va_end(ap);
    return 0;
}
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


## 6. 前向转发模式

可变参数封装函数常见写法是“外层收集，内层 `v*` 接口处理”，例如 `printf` 对应 `vprintf`。这种分层能减少重复实现，也让协议检查集中在一个入口上。

## 7. 协议字段应可校验

无论你使用“数量字段”还是“格式字符串”，都要确保协议能在入口处完成基本校验。数量字段要检查上限与溢出风险，格式字符串要限制可接受格式集合。协议若不可校验，可变参数接口就会退化为不可验证的隐式约定。

## 8. 让可变参数停留在边界层

可变参数更适合作为人机接口或日志接口这类边界能力，而不是核心业务函数的常态签名。核心计算路径若依赖可变参数，会让类型检查能力大幅下降。一个常见组织方式是：边界层收集参数，内部转换成明确结构后再调用普通函数。
