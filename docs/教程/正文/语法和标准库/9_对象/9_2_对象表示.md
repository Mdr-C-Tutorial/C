# 对象表示

本节介绍对象表示 (Object representation) 与值表示 (Value representation)。

你可以把它们理解为：

1. **对象表示**：对象在内存（抽象机器的字节序列）中的“原始字节形态”。
2. **值表示**：在这些字节形态中，哪些位模式 (Bit pattern) 对应“有效的值”。

这一区分解释了很多看似奇怪但非常重要的现象：例如“为什么同样是 4 字节，某些位模式对 `float` 是陷阱表示 (Trap representation)？”、“为什么结构体中会出现填充字节 (Padding)？”。

## 1. 对象表示 vs 值表示

### 1.1 对象表示 (Object representation)

对象表示是对象占据的那段连续字节的内容。标准允许你通过字符类型（`char`、`signed char`、`unsigned char`）观察并复制对象表示。

### 1.2 值表示 (Value representation) 与填充位

对某些类型而言，并非所有位模式都对应一个合法值：

1. 某些位可能是**填充位** (Padding bit)；
2. 某些位模式可能是**陷阱表示** (Trap representation)。

当一个对象的对象表示对应陷阱表示时，对该对象按其类型进行求值（读出“值”）可能触发 UB。

::: warning 实践建议

除非你确实在做底层库（序列化、校验、哈希、协议），否则应尽量避免依赖“具体对象表示”。对象表示通常是实现定义的（例如大小端、浮点格式）。

:::

## 2. 观察对象表示：标准写法

### 2.1 使用 `unsigned char` 查看字节

```c
#include <stddef.h>
#include <stdio.h>

static void dump_bytes(const void* p, size_t n) {
    const unsigned char* b = (const unsigned char*)p;
    for (size_t i = 0; i < n; i++) {
        printf("%02x%s", (unsigned)b[i], (i + 1 == n) ? "" : " ");
    }
    putchar('\n');
}

int main(void) {
    unsigned x = 0x11223344u;
    dump_bytes(&x, sizeof x);
    return 0;
}
```

可能的输出（示例）：

<TerminalWindow>

<输出与输入或平台相关，请以实际运行为准>

</TerminalWindow>


该输出与机器的字节序 (Endianness) 有关：

1. 若是小端序，通常输出 `44 33 22 11`；
2. 若是大端序，通常输出 `11 22 33 44`。

注意：字节序属于实现定义行为 (Implementation-defined behavior)。

### 2.2 使用 `memcpy` 在类型之间搬运对象表示

如果你想“把某个对象的对象表示解释成另一种类型”，标准最稳妥的方式是 `memcpy`（而不是指针强转后解引用）。

示例见 [9.1 内存模型](/教程/正文/语法和标准库/9_对象/9_1_内存模型) 中的 `float` / `uint32_t` 示例。

## 3. 对齐相关

对象表示与对齐密切相关：对齐决定了对象能出现在哪些地址上，也影响结构体内部的填充布局。

1. [9.2.1 对齐](/教程/正文/语法和标准库/9_对象/9_2_对象表示/9_2_1_对齐)
2. [9.2.2 alignof](/教程/正文/语法和标准库/9_对象/9_2_对象表示/9_2_2_alignof)

## 4. 习题

1. 写程序分别观察 `uint16_t`、`uint32_t`、`uint64_t` 的字节序输出，并总结你的平台是大端还是小端。
2. 写程序观察以下类型的 `sizeof` 与 `alignof`（见 9.2.2）：`char`、`int`、`double`、`max_align_t`。
3. 设计一个“结构体布局观察”实验：对 `struct { char a; int b; char c; }` 输出：
   1. `sizeof`；
   2. `offsetof`（需要 `<stddef.h>`）；
   3. 对象表示（建议先把对象整体置零，再写入成员值）。
