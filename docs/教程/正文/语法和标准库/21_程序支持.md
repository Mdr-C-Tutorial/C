# 程序支持

程序支持库处理的是“程序如何与运行环境交互”这条主线：如何结束进程、如何读取外部环境信息、如何在必要时进行非局部跳转。它们看似零散，实质都在回答同一个问题——当控制流走到边界时，程序应如何有序收束。

## 1. 本章结构

本章先讲 [21.1 终止程序](/教程/正文/语法和标准库/21_程序支持/21_1_终止程序.md)，明确 `return`、`exit`、`quick_exit`、`_Exit`、`abort` 之间的清理语义差别；再讲 [21.2 环境访问](/教程/正文/语法和标准库/21_程序支持/21_2_环境访问.md)，覆盖命令行参数、环境表项和 `system`；最后讲 [21.3 跳转](/教程/正文/语法和标准库/21_程序支持/21_3_跳转.md)，说明 `setjmp` / `longjmp` 的边界与约束。

## 2. 阅读时的关注点

这一章的关键不是“记住函数名”，而是分清每个接口对资源状态和控制流语义的承诺。比如同样是结束程序，不同终止路径对已打开流、已注册回调和可观察副作用的处理完全不同；同样是跳转，结构化 `return` 与非局部 `longjmp` 对可读性和可验证性的影响也不一样。

## 3. 使用建议

建议把“程序边界行为”当成接口契约的一部分写进模块文档：出错时怎样终止、何时读取环境、是否允许非局部跳转。边界语义越清楚，后续维护越容易避免隐式依赖。

## 4. 一个最小边界约定示例

例如命令行工具可以约定：参数错误返回 `2`，运行失败返回 `1`，成功返回 `0`。这类约定虽然简单，但它把“程序语义”暴露给外层调度系统，能让脚本与自动化流程稳定协作。

```c
#include <stdlib.h>

enum {
    APP_OK = 0,
    APP_BAD_ARGS = 2,
    APP_RUNTIME_FAIL = 1
};

static int run(const char *arg) {
    return (arg == NULL || arg[0] == '\0') ? -1 : 0;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        return APP_BAD_ARGS;
    }
    if (run(argv[1]) != 0) {
        return APP_RUNTIME_FAIL;
    }
    return APP_OK;
}
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


## 5. 与错误处理章节的衔接

程序支持章节讨论的是边界动作，错误处理章节讨论的是错误表达方式。把两者结合起来时，可以形成清晰链路：内部用返回值和错误码传递失败原因，最外层把失败归并为稳定退出码并完成终止路径收束。

## 6. 库代码与进程边界

若代码以库形式被上层调用，通常应避免在库内部直接 `exit` 或 `abort`，而是把失败信息返回给调用方决定如何收束进程。这样可以保持调用方对程序边界行为的控制权，也更便于复用。

## 7. 边界动作集中在最外层

一个清晰的组织方式是：内部函数只返回状态与错误信息，最外层入口统一决定“打印什么、返回什么、是否终止”。这样可以避免边界动作在各层散落，调用链也更容易保持可预测行为。程序支持库的接口往往就用在这条最外层收束路径上。

## 8. 退出码语义应与调用方对齐

程序边界不仅面对人类读者，也面对脚本、调度器和服务编排系统。若退出码语义在不同工具间不一致，上层自动化就会误判结果。建议在入口层固定一套退出码映射规则，并在文档中明确“哪些失败属于可重试、哪些属于不可重试”。

## 9. 边界接口尽量保持幂等语义

环境读取、终止路径、非局部跳转这类接口一旦被重复触发，行为往往会迅速复杂化。设计时若能让关键收束动作保持幂等或可重复调用安全，异常链路会更稳定。即使未来接入新平台或新运行时，这种边界语义也更容易迁移。

```c
#include <stdio.h>

typedef struct {
    FILE *log_fp;
    int closed;
} app_ctx;

void app_close(app_ctx *ctx) {
    if (ctx == NULL || ctx->closed) {
        return;
    }
    if (ctx->log_fp != NULL) {
        fclose(ctx->log_fp);
        ctx->log_fp = NULL;
    }
    ctx->closed = 1;
}
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。

