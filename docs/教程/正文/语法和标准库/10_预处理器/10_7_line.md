# `#line`

`#line` 指令用于修改后续代码中 `__LINE__` 与 `__FILE__` 的逻辑值。它主要服务于“代码生成器”场景：当源代码由工具生成时，编译诊断可以映射回原始输入文件。

## 1. 基本形式

```c
#line 120 "schema.dsl"
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


从这一行之后，预处理器会把行号视为 `120`，文件名视为 `schema.dsl`。编译器报错、`assert` 信息、调试输出中的位置元数据也会随之变化。

## 2. 示例

```c
#include <stdio.h>

int main(void) {
#line 42 "generated_from_template.c"
    printf("%s:%d\n", __FILE__, __LINE__);
    return 0;
}
```

可能的输出（示例）：

<TerminalWindow>

<输出与输入或平台相关，请以实际运行为准>

</TerminalWindow>


输出会显示为 `generated_from_template.c:42`。这能让用户在阅读诊断时定位到“真正编辑的源”，而不是中间产物。

## 3. 使用边界

手写业务代码通常不需要 `#line`。只有在“源到源转换”链路中，需要保持诊断可追踪时，它才值得使用。滥用会让调试信息失真，反而增加排错难度。

## 4. 生成代码中的常见用法

很多代码生成器会在生成片段前插入 `#line`，把后续诊断映射回模板或 DSL 文件。这样当编译器报告某行语法错误时，用户看到的是原始输入位置，而不是中间产物位置。

```c
#line 8 "model.idl"
struct person {
    int id;
    const char *name;
};
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


如果这段定义触发诊断，报错位置会落到 `model.idl` 的对应行，排错路径会更短。

## 5. 与日志宏的配合边界

`#line` 会影响 `__FILE__` / `__LINE__`，因此也会影响基于这些宏构建的日志与断言信息。在手写模块里滥用 `#line`，可能让运行日志定位到“伪文件名”，增加排障成本；在生成代码里使用它时，则应把映射策略写入生成器文档。

## 6. 指令形式补充

`#line` 既可以只给出行号，也可以同时给出文件名。两种形式都作用于“后续行”的逻辑位置元数据。生成器若只需要校正行号，可使用短形式；若还需要映射来源文件，再补充文件名参数。

## 7. 维护一致性建议

若项目内有多个代码生成器，建议统一 `#line` 映射格式（文件名风格、行号基准、插入位置）。格式统一后，构建日志和诊断平台更容易聚合同类问题，排障链路会更稳定。

## 8. 生成器中的位置回退策略

当生成器在同一输出文件中混合“模板片段”和“自动扩展片段”时，建议在不同片段切换处显式恢复 `#line` 映射，避免诊断长期停留在错误来源文件名。位置映射如果前后不闭合，后续报错会落到错误上下文，反而削弱 `#line` 的价值。
