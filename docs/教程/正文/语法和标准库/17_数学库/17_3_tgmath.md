# 泛型数学

`<tgmath.h>`（type-generic math）提供一组“泛型”宏，让你可以用一个名字调用到正确的数学函数版本：

1. 当实参是 `float` 时，选择带 `f` 后缀的版本（如 `sinf`）。
2. 当实参是 `double` 时，选择不带后缀的版本（如 `sin`）。
3. 当实参是 `long double` 时，选择带 `l` 后缀的版本（如 `sinl`）。
4. 当实参是复数类型时（见 17.2），选择 `<complex.h>` 中的对应版本（如 `csin`）。

它的价值在于：当你写“泛型代码”或希望尽量少写后缀时，代码更紧凑；但它的本质是宏展开，仍然需要你理解底层函数的语义与定义域要求。

## 示例

```c
#include <tgmath.h>
#include <stdio.h>

int main(void) {
    float x = 0.5f;
    double y = 0.5;

    printf("%.6f\n", sin(x)); /* 实参是 float：等价于 sinf(x) */
    printf("%.6f\n", sin(y)); /* 实参是 double：等价于 sin(y) */
    return 0;
}
```

可能的输出（示例）：

<TerminalWindow>

<输出与输入或平台相关，请以实际运行为准>

</TerminalWindow>


::: warning 注意

1. `<tgmath.h>` 的接口是宏；宏会参与表达式求值，因此要避免把带副作用的表达式当作实参反复展开（例如 `sin(i++)` 这类写法）。
2. 如果你不需要泛型，直接使用 `<math.h>` 的明确函数名通常更直观。

:::

## 选择规则的直觉

可以把 `<tgmath.h>` 理解为“根据实参类型分派到对应函数族”的语法糖。它帮助你减少后缀选择负担，但不会改变底层数学函数的定义域、误差模型或错误语义。也就是说，泛型入口解决的是接口简化，不是数值语义变化。

## 适用边界

当代码需要明确控制类型（例如强制使用 `long double` 路径）时，直接调用带后缀函数名通常更清楚。泛型宏更适合教学、原型验证或类型自然随实参推导的通用代码。

## 实参类型决定分派结果

`<tgmath.h>` 的分派依据是实参类型而不是左值接收类型。也就是说，即便你把结果赋给 `double`，只要实参是 `float`，仍会走 `float` 版本。若你希望固定到某个精度路径，应先把实参显式转换到目标类型，再调用泛型入口。

```c
#include <tgmath.h>

double f(float x) {
    return sin((double)x); /* 分派到 double 路径 */
}
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


## 复杂表达式里优先先分步再调用

虽然泛型宏能简化调用名，但在复杂表达式中直接嵌套多个泛型调用，常常会让类型分派路径不直观。更清晰的方式是先把关键中间结果落到命名对象，再逐步调用函数族。这样既便于读者确认类型，也便于定位数值误差来源。

## 习题

<Exercise id="11731" :d="3" :w="2">

写一个程序：分别以 `float` 与 `double` 读入同一个数值，调用 `<tgmath.h>` 的 `sqrt` 并输出结果。

要求：

1. 程序应同时包含 `float` 与 `double` 两条路径；
2. 输出时分别标注类型；
3. 输入失败时退出。

</Exercise>
