# 本地化库

本地化库 (Localization) 让程序根据地区规则处理数字、货币、排序和消息文本。它的核心头文件是 `<locale.h>`，并与 `<ctype.h>`、`<string.h>`、`<wchar.h>` 等库能力联动。

这部分能力主要面向宿主实现；若目标是独立实现环境，需要先确认运行时是否提供对应支持。

## 1. 核心接口 `setlocale`

`setlocale` 用于查询或设置当前本地化类别。若设置失败会返回空指针，因此任何切换动作都应检查返回值。

```c
#include <locale.h>
#include <stdio.h>

int main(void) {
    const char *result = setlocale(LC_ALL, "");
    if (result == NULL) {
        puts("setlocale failed");
        return 1;
    }

    puts(result);
    return 0;
}
```

可能的输出（示例）：

<TerminalWindow>

<输出与输入或平台相关，请以实际运行为准>

</TerminalWindow>


传入空字符串 `""` 的常见语义是“按运行环境默认地区设置初始化”。

## 2. 数字与货币格式

`localeconv` 返回当前地区的格式描述，例如小数点符号和货币分隔。它适合在“展示层”做格式化，而不应拿来改变核心计算逻辑。计算逻辑应保持地区无关，输入输出再做本地化适配。

## 3. 排序与比较

字符串排序若需要遵循地区规则，应优先使用 `strcoll` 和 `strxfrm`，而不是直接按字节比较。字节序比较只适合协议字段和机器可读数据，不适合人类语言文本。

## 4. 实践建议

本地化配置应在程序启动早期一次性完成，避免在业务流程中频繁切换全局地区状态。若项目规模较大，建议把“格式化输出”集中在独立模块中管理，避免全局状态影响扩散。

## 5. 全局状态边界

`setlocale` 修改的是进程级全局地区状态，不是某个调用点私有状态。若在运行过程中反复切换地区，其他模块的格式化行为也会被连带影响。更稳妥的方式是尽量减少切换次数，把地区相关输出集中到边界层处理。

## 6. 与多字节/宽字符库的关系

本地化不仅影响排序和格式，也会影响多字节字符转换与宽字符处理的语义。涉及 `<wchar.h>`、`<wctype.h>` 的代码时，应明确地区前提，避免在不同执行环境下得到不一致结果。

## 7. 多线程程序中的使用边界

由于地区设置是进程级全局状态，多线程程序若在运行期频繁调用 `setlocale`，很容易引入跨线程可见行为变化。更稳妥的方式是在线程启动前完成一次性初始化，后续线程只读取既定地区配置，避免在并发执行阶段动态切换全局地区。
