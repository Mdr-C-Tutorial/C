# 数组

## 1. 数组声明和初始化

### 1.1 数组声明

### 1.2 数组初始化

1. 字符串字面量初始化字符数组：可以把字符串字面量放在花括号里，但更多情况下省略。

   如果数组的大小未知，那么字符串字面量里面的每个字符（包括空终止字符）用来初始化数组的各个元素；如果数组的大小已知，允许数组大小比字符串字面量的大小少 1，此时数组里无空终止字符。

   ```c
   char arr1[] = "mdr";
   char arr2[] = { "mdr" };
   // arr1 和 arr2 为 { 'm', 'd', 'r', '\0' }

   char arr3[3] = "mdr";
   // arr3 为 { 'm', 'd', 'r' }
   ```

2. 花括号环绕的初始化器列表初始化数组

   每个初始化器前面可以带一个形如 `[ 下标 ] =` 的**指派符**，指定这个初始化器初始化该数组的第 _下标_ 个元素。如果一个初始化器无指派符，如果它是第一个初始化器则初始化下标为零的元素，否则初始化前一个初始化器初始化的元素的后一个元素。

   如果数组的大小未知，那么初始化器的最大下标会确定数组大小（也就是足够装得下数组里面的元素），同时在初始化过后，数组从不完整类型变成完整类型。

   ```c
   int arr1[3] = { 1, 2, 3 };
   int arr2[]  = { [2] = 5 };          // { 0, 0, 5 }
   int arr3[]  = { [2] = 5, 6, 7}      // { 0, 0, 5, 6, 7 }
   int arr4[]  = { 1, 2, 3, [2] = 5 }; // { 1, 2, 5 }
   ```

   用嵌套初始化器初始化数组的数组：

   ```c
   int arr[3][2] = { {1, 2}, {3, 4}, {5, 6} };
   int arr[3][2] = { {1}, {3, 4}, {[1] = 6} }; // { { 1, 0 }, { 3, 4 }, { 0, 6 } }
   ```

   如果嵌套的初始化器外围没有花括号，就会用尽可能多的初始化器依次初始化子数组的各个元素。

   ```c
   int arr1[3][2] = { 1, {2}, {3, 4} }; // { { 1, 0 }, { 2, 0 }, { 3, 4 } }
   int arr2[3][2] = { 1, 2, 3, 4 };     // { { 1, 2 }, { 3, 4 }, { 0, 0 } }
   ```

   指派符可以嵌套：

   ```c
   int arr1[3][2] = { [2][1] = 3 }; // { { 0, 0 }, { 0, 0 }, { 0, 3 } }
   ```

## 浅触动态内存分配

## 习题

1. _[1.3]_ 输入两个整数 m 和 n（均小于 100），代表矩阵的行数和列数。接着输入两个 m x n 的整数矩阵 A 和 B。计算它们的和矩阵 C = A + B，并输出矩阵 C。

2. _[M5.7**]_ 输入 $n\space(n<10000)$，通过割圆术计算圆周率精确到小数点后 $n$ 位的值。

3. _[3.4]_ 设计程序，模拟“生命游戏”：
   1. 世界由 $n*n$ 个方格组成，每个方格有两种状态：要么有生命，要么无生命；
   2. 每个方格周围的 8 个方格（边 5 个，角 3 个）称为它的“邻居”；
   3. 在每代演化中，如果某方块有生命且其邻居中的 2 个或 3 个有生命，则该方块在下一代中保持有生命；如果该方块无生命且其邻居中的 3 个有生命，则该方块在下一代中变为有生命；其余情况则保持不变。

   首先输入世界大小 $n$；再输入 $n*n$ 个数，作为第 0 代时的每个方格的状态；最后输入 $m$ 作为演化的代数：输出第 $m$ 代的的演化结果。

4. 给定一个正整数 n，计算并输出 n 的阶乘（n!）的值。
5. 输入维数 n，再输入两个 n 维向量在某直角坐标系内的坐标，输出它们的夹角。
