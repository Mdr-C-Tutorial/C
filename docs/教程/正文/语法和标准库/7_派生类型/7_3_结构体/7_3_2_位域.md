# 位域

位域 (Bit-field) 是结构体成员的一种声明形式，用来按“位宽”而不是按“完整类型宽度”分配存储。它适合表达硬件寄存器标志位、协议头部标记或紧凑状态位集合。

## 1. 基本语法

位域成员在结构体中声明为 `类型 成员名 : 位宽`，其中位宽必须是非负整数常量表达式。

```c
struct flags {
    unsigned int carry : 1;
    unsigned int zero : 1;
    unsigned int mode : 2;
};
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


上例中 `carry` 和 `zero` 各占 1 位，`mode` 占 2 位。实际布局顺序、填充方式、跨存储单元策略由实现定义，因此跨平台二进制协议不能直接依赖位域内存布局。

## 2. 常见约束

位域只能作为结构体或联合体成员声明，不能单独定义为普通对象。对位域不能取地址，也不能把它当作普通对象指针目标使用。

```c
struct status {
    unsigned int ready : 1;
};

/* &s.ready 是不合法的 */
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


此外，类型为 `int` 的位域其有符号性可能由实现决定；若需要确定语义，建议显式写 `signed int` 或 `unsigned int`。

## 3. 宽度为 0 的匿名位域

匿名位域可用于占位或控制下一个成员的对齐边界，其中“宽度为 0”表示强制从下一个存储单元开始放置后续位域。

```c
struct header {
    unsigned int a : 3;
    unsigned int : 0;  /* 强制换到下一个存储单元 */
    unsigned int b : 3;
};
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


这种写法在与硬件文档对齐时很有用，但仍然要结合目标编译器文档验证布局结果。

## 4. 使用建议

位域适合“同一编译器、同一 ABI、同一目标平台”的内部表示；若数据需要跨平台序列化，建议改用显式掩码与移位操作，对字节序与位序进行手动控制，这样更符合可移植性要求。

## 5. 并发访问提示

位域写入常常对应底层存储单元的读改写过程，而不是独立位的原子更新。若多个线程并发修改同一存储单元中的不同位域，仍可能产生竞态。涉及并发读写时，应配合同步原语或改用显式原子对象方案。

## 6. 位宽越界与赋值截断

给位域赋值时，若值超出可表示范围，结果依实现而定，代码可读性也会显著下降。更清晰的写法是先在普通无符号整数对象里做范围约束，再写入位域，这样意图和边界都更明确。

```c
struct reg_bits {
    unsigned int mode : 2;
};

void set_mode(struct reg_bits *r, unsigned int mode) {
    r->mode = mode & 0x3u;
}
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


## 7. 与显式掩码方案的取舍

位域更接近“语义结构”，掩码与移位更接近“精确布局控制”。当目标是同一工具链下的人类可读状态表达，位域通常更直接；当目标是跨平台协议或磁盘格式，显式掩码往往更可控。两种写法没有绝对高低，关键在于是否需要固定二进制布局。
