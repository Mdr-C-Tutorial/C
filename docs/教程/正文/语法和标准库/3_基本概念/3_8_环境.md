# 环境

## 1. 翻译环境与执行环境

C 标准把程序生命周期分为翻译环境和执行环境。翻译环境负责把源代码处理为可执行映像，执行环境负责真正运行程序。很多“编译通过但运行异常”的问题，本质是把这两层混在一起：编译阶段只能检查语法与约束，运行阶段才会触发输入输出、内存访问和并发调度等行为。

## 2. 宿主实现与独立实现

宿主实现 (Hosted Implementation) 通常运行在操作系统之上，`main` 是标准入口，标准库可用范围完整。独立实现 (Freestanding Implementation) 常见于内核、固件与启动代码，标准库只保证最小子集，程序入口也未必是 `main`。写可移植代码时，先判断目标属于哪种环境，再决定可依赖的接口。

## 3. 一个最小判断示例

```c
#include <stdio.h>

int main(void) {
#ifdef __STDC_HOSTED__
    printf("__STDC_HOSTED__ = %d\n", __STDC_HOSTED__);
#endif
    return 0;
}
```

可能的输出（示例）：

<TerminalWindow>

<输出与输入或平台相关，请以实际运行为准>

</TerminalWindow>


当输出为 `1` 时，表示按宿主环境处理；为 `0` 时，表示独立环境。这个宏不能替代完整平台文档，但可以作为源码中的清晰分支条件。

## 4. 使用建议

凡是涉及文件系统、进程控制、线程或本地化的能力，都应在文档中明确环境前提。若某接口只在宿主环境成立，就不要把它表述成“通用 C 能力”；若目标是独立环境，就优先选择无隐式依赖的最小接口集。

## 5. 入口点约定的差异

在宿主环境里，程序入口通常是 `main`，并由运行时负责完成启动与退出收尾；在独立环境里，入口点可能是平台约定的初始化函数，且运行时能力可能极小。写启动代码时，应把“入口、初始化顺序、可用库”当成同一个约束集合来处理，而不是只改函数名。

## 6. 文档里的环境前提写法

当章节依赖宿主能力时，可以在开头明确标注“本节默认宿主实现”；当章节可在独立环境复用时，再单独说明需要替换或裁剪的部分。这样读者在迁移到固件或内核场景时，不会误把宿主接口当成语言必备能力。

## 7. 条件分支入口建议

跨环境代码常见入口是 `__STDC_HOSTED__` 配合平台宏做分支选择。建议把分支入口集中在少量适配层文件，避免环境判断散落到业务逻辑。这样后续迁移目标环境时，改动范围会更可控。

## 8. 把环境差异固定在接口层

无论是宿主实现还是独立实现，都建议先定义一层稳定的内部接口，再在这层之下对接具体环境能力。这样上层语义就不必关心“当前是否有文件系统、是否支持进程与命令处理器”，也能避免同一业务逻辑在不同环境分叉成两套实现。环境章节真正要建立的，是这种“先分层、后适配”的思维方式。
