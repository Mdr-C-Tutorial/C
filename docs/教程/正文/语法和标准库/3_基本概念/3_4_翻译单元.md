# 翻译单元

## 1. 基本定义

预处理完成后得到的源文件称为一个翻译单元 (Translation Unit)。它由外部声明序列组成，例如函数定义、对象定义、`typedef` 声明和 `extern` 声明。编译器先分别处理各翻译单元生成目标文件，再由链接器把目标文件与库连接为最终程序。

## 2. 为什么它是模块边界

同名标识符能否共存、某个符号能否被其他源文件访问，都取决于翻译单元边界和链接属性。`static` 影响可见性，头文件影响声明一致性，链接器负责把调用点与定义点绑定。理解翻译单元，才能正确理解“声明写在哪”“定义放在哪”。

## 3. 一个最小示例

```c
/* math_ext.h */
#ifndef MATH_EXT_H
#define MATH_EXT_H

int add(int lhs, int rhs);

#endif
```

```c
/* math_ext.c */
#include "math_ext.h"

int add(int lhs, int rhs) {
    return lhs + rhs;
}
```

```c
/* main.c */
#include <stdio.h>
#include "math_ext.h"

int main(void) {
    printf("%d\n", add(3, 4));
    return 0;
}
```

`main.c` 和 `math_ext.c` 是两个翻译单元。它们都包含同一个头文件，从而共享一致声明。链接阶段再把 `add` 的调用点和定义点连起来。

## 4. 头文件重复包含

头文件会被预处理器按文本插入，同一头文件可能被多次包含。如果缺少包含保护，重复声明和重复定义会直接破坏翻译单元语义。包含保护（或 `#pragma once`）不是风格问题，而是构建正确性问题。
