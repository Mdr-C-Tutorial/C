# 作用域

作用域 (Scope) 描述“一个标识符在源代码中可见的区域”。它是静态语义规则，与对象是否已经创建是两个概念。理解作用域可以直接避免命名冲突、阴影覆盖和接口泄露。

## 1. 四种常见作用域

文件作用域从声明点持续到翻译单元结尾；块作用域从声明点持续到当前复合语句结束；函数原型作用域只在函数声明的形参列表内有效；标号作用域覆盖整个函数体。它们共同决定了同名标识符何时表示“同一个实体”，何时表示“不同实体”。

## 2. 块作用域与阴影覆盖

```c
#include <stdio.h>

int main(void) {
    int x = 1;

    {
        int x = 2;
        printf("inner x = %d\n", x);
    }

    printf("outer x = %d\n", x);
    return 0;
}
```

可能的输出（示例）：

<TerminalWindow>

<输出与输入或平台相关，请以实际运行为准>

</TerminalWindow>


内层块重新声明了同名标识符，外层名字在该块中被遮蔽。程序合法，但可读性会下降。除非刻意表达“局部覆盖”，否则建议避免这种写法。

## 3. 文件作用域与接口边界

文件作用域标识符若配合 `static`，只在当前翻译单元可见；不加 `static` 则可能形成外部链接。前者适合模块内部实现细节，后者适合跨文件接口。把这条边界划清，可以显著降低耦合。

## 4. 函数原型作用域

函数声明中的形参名只在该原型内部有效，它们主要用于可读性和文档化，不会在原型外形成可见名字。

```c
int add(int left, int right);  /* left/right 仅在这个声明里有效 */

int add(int a, int b) {
    return a + b;
}
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


定义阶段可以使用不同的形参名，类型匹配才是关键约束。把“声明用于接口，定义用于实现”这层分工理清后，代码组织会更清楚。

## 5. 标号作用域补充

`label:` 的可见范围覆盖整个函数体，因此 `goto` 可以跨块跳转到该标号，但目标仍必须位于同一函数内。它不受普通块作用域限制。

```c
int f(int x) {
    if (x < 0) {
        goto fail;
    }
    return 0;

fail:
    return -1;
}
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


这类写法常用于统一失败出口，但仍应控制在清晰、可验证的范围内。

## 6. 声明点的时间边界

块作用域标识符并不是“进入块就可见”，而是从声明点之后才可见。这个细节在同名遮蔽和长函数重构中很关键：把声明移动到更窄的位置，能自然收缩可见范围，也能减少误用旧名字的机会。

```c
int x = 1;
{
    /* 此处仍是外层 x 可见 */
    int x = 2; /* 从这里开始，内层 x 可见 */
}
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


## 7. 把可见性收敛到最小单元

作用域设计的核心目标是降低名字冲突和语义漂移。将对象声明放在首次使用附近、将仅模块内部使用的实体限制在文件作用域 `static`、把公共名称集中在头文件并带统一前缀，这三条组合起来通常就能显著提升代码可读性与可维护性。
