# 整数常量、浮点常量和字符常量

常量写法不仅影响可读性，也会直接影响类型推导、溢出风险和可移植性。写对字面量，是“表达式正确求值”的第一步。

## 1. 整数常量

整数常量支持十进制、八进制、十六进制和（C23 起）二进制形式。前缀分别是无前缀、`0`、`0x`/`0X`、`0b`/`0B`。后缀 `u`、`l`、`ll` 及其组合用于指定无符号或更宽类型。

```c
int a = 42;          /* 十进制 */
int b = 052;         /* 八进制，值为 42 */
int c = 0x2A;        /* 十六进制 */
int d = 0b101010;    /* 二进制，C23 */
unsigned long long e = 42ull;
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


标准会根据常量形式和后缀选择“能容纳该值的首个类型”。如果你希望类型明确可读，直接写后缀或使用 `<stdint.h>` 的宏常量最稳妥。

若你的编译器尚未切到 C23，二进制前缀 `0b` 可能不可用，这时可优先改写为十六进制常量。

## 2. 浮点常量

浮点常量可写成十进制科学计数法，也可写成十六进制浮点形式。后缀 `f`/`F` 指定 `float`，`l`/`L` 指定 `long double`，无后缀默认 `double`。

```c
double x = 3.1415926;
double y = 1.0e-3;
double z = 0x1.8p+2;   /* 十六进制浮点，值为 6.0 */
float  w = 6.02e23f;
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


十六进制浮点在描述二进制可精确表示值时很有优势，适合写底层测试和数值边界用例。

## 3. 字符常量

普通字符常量使用单引号包围，例如 `'A'`。其类型通常是 `int`，值为执行字符集中对应字符编码。转义序列如 `'\n'`、`'\0'`、`'\x41'` 可表达不可见字符或指定码位。

```c
#include <stdio.h>

int main(void) {
    int a = 'A';
    int b = '\n';
    int c = '\x41';

    printf("%d %d %d\n", a, b, c);
    return 0;
}
```

可能的输出（示例）：

<TerminalWindow>

<输出与输入或平台相关，请以实际运行为准>

</TerminalWindow>


多字符常量（如 `'AB'`）是实现定义行为，不建议用于可移植代码。若要表达文本，请优先使用字符串字面量。

## 4. 写作建议

不要把“字面上看起来一样”当作“类型一定一样”。`1`、`1u`、`1.0`、`1.0f` 在常量转换规则里是不同实体。把类型意图写在常量上，比依赖隐式转换更安全。

## 5. 整数字面量前导零的风险

整数字面量前导零会触发八进制语义，这是代码审查中非常常见的误读来源。像 `010` 并不是十进制十，而是八进制八。涉及权限位、掩码或协议常量时，建议优先使用十六进制并配套注释语义，这样读者更不容易把进制看错。

## 6. 字面量与接口类型保持一致

常量写法应尽量贴合接口所需类型，例如位掩码接口使用无符号后缀，单精度计算明确使用 `f` 后缀。这样可以减少不必要的隐式转换，也能让编译器告警更早暴露真正的不匹配问题。字面量本身就是接口契约的一部分，写清楚会显著提升可读性。
