# `sizeof` 运算符

`sizeof` 用于取得类型或表达式结果类型的大小，结果类型是 `size_t`。它常被当作“语法细节”，但在内存布局、数组长度计算和接口泛化中几乎无处不在。

## 1. 两种写法与一个习惯

`sizeof(type-name)` 对类型取大小，`sizeof expr` 对表达式结果类型取大小。第二种写法语法上可省括号，但为了避免优先级歧义，通常写成 `sizeof(expr)` 更清楚。

```c
size_t a = sizeof(int);
size_t b = sizeof(1 + 2.0);   /* 等价于 sizeof(double) */
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


## 2. 不求值语境与 VLA 例外

多数情况下，`sizeof(expr)` 不会执行 `expr`，所以其中副作用不会发生；但若 `expr` 的类型属于可变修改类型（例如 VLA），实现可能需要在运行期计算大小，此时表达式会被求值。写带副作用的 `sizeof` 表达式通常不是好主意，分离计算步骤更稳妥。

## 3. 数组与指针的区别

`sizeof` 对数组给出整个数组占用字节数，对指针只给出指针对象本身大小。这个差别是很多越界错误的来源。

```c
int arr[10];
int *ptr = arr;

size_t n1 = sizeof(arr) / sizeof(arr[0]);  /* 10 */
size_t n2 = sizeof(ptr) / sizeof(ptr[0]);  /* 通常不是 10 */
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


因此，数组长度推导应尽量发生在数组仍保持数组类型的作用域内，不要等它退化为指针后再计算。

## 4. 常用写法

分配内存时，`sizeof *p` 通常比 `sizeof(type)` 更抗重构：当对象类型调整时，表达式能自动同步，减少遗漏。

```c
#include <stdlib.h>

int *p = malloc(count * sizeof *p);
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


## 5. 结构体大小与填充

`sizeof(struct T)` 包含实现为满足对齐而插入的填充字节，因此不一定等于各成员 `sizeof` 之和。需要精确二进制布局时，应结合 `_Alignof`、成员顺序和目标 ABI 文档一起判断，而不是只凭直觉相加。

## 6. 与参数退化的配合

在函数形参位置，`int arr[]` 会调整为 `int *arr`，此时 `sizeof(arr)` 得到的是指针大小而非数组总字节数。若函数需要数组长度，应通过额外参数显式传入，或在调用点先计算再传递，避免在被调函数内部推导错误。

## 7. 习题

<Exercise id="10419" :d="4" :w="3">

写一个程序，分别输出：

1. `sizeof(int)`
2. `sizeof(double)`
3. `sizeof(char)`

然后解释这三个结果为何可能不同。

</Exercise>
