# 逻辑运算符

::: tip 可以暂时跳过

在学习[**语句**](/教程/正文/语法和标准库/5_语句.md)之前，逻辑运算符没什么用处。

:::

逻辑运算符作用于标量类型的操作数，对其求值的结果是 `int` 类型的 `1` 或 `0`。其结果通常用在[**语句**](/教程/正文/语法和标准库/5_语句.md)（如 `if`, `while`）的条件部分。

为了符合对于逻辑的普遍认识，下文（包括下面的数个章节）用**真**指代某标量对象不等于 `0`，用**假**指代某标量对象等于 `0`。

## 逻辑与 `&&`

**逻辑与 (Logical AND)** 是一个二元运算符。当且仅当**两个操作数都为真**（即都为非零值）时，其运算结果才为**真 (`1`)**。只要有一个操作数为假（即为 `0`），结果就为**假 (`0`)**。

| 操作数1 (逻辑) | 操作数2 (逻辑) | 结果  |
| :------------: | :------------: | :---: |
|       真       |       真       |  `1`  |
|       真       |       假       |  `0`  |
|       假       |       真       |  `0`  |
|       假       |       假       |  `0`  |

**示例：**

```c
int a = 5;
int b = 0;

int result = (a > 1) && (b == 0); // (5 > 1)为真，(0 == 0)为真
                                  // 真 && 真 -> 结果为 1
```

::: info 短路求值 (Short-circuit Evaluation)

逻辑与 `&&` 具有**短路**特性。如果第一个操作数求值为**假**（即 `0`），那么整个表达式的结果就已经确定为假，此时**第二个操作数将不会被求值**。这对于避免不必要或危险的计算非常重要。

在 `&&` 运算符的左操作数的求值后有一个**序列点**。

:::

## 逻辑或 `||`

**逻辑或 (Logical OR)** 是一个二元运算符。只要**两个操作数中至少有一个为真**（即为非零值），其运算结果就为**真 (`1`)**。只有当两个操作数都为假（都为 `0`）时，结果才为**假 (`0`)**。

| 操作数1 (逻辑) | 操作数2 (逻辑) | 结果  |
| :------------: | :------------: | :---: |
|       真       |       真       |  `1`  |
|       真       |       假       |  `1`  |
|       假       |       真       |  `1`  |
|       假       |       假       |  `0`  |

**示例：**

```c
int score = 85;
// 检查分数是否无效 (小于 0 或 大于 100)
int is_invalid = (score < 0) || (score > 100);
// (85 < 0)为假, (85 > 100)为假
// 假 || 假 -> 结果为 0
```

::: info 短路求值

逻辑或 `||` 同样具有**短路**特性。如果第一个操作数求值为**真**（即非零），那么整个表达式的结果就已经确定为真，此时**第二个操作数将不会被求值**。

在 `||` 运算符的左操作数的求值后有一个**序列点**。

:::

## 逻辑非 `!`

**逻辑非 (Logical NOT)** 是一个一元运算符，它会**反转**其操作数的逻辑状态。

* 如果操作数为**假**（即 `0`），结果为**真 (`1`)**。
* 如果操作数为**真**（即非零值），结果为**假 (`0`)**。

所以，逻辑非 `!a` 与 `(a == 0)` 等价。

| 操作数 (逻辑) | 结果  |
| :-----------: | :---: |
|      真       |  `0`  |
|      假       |  `1`  |

**示例：**

```c
int has_error = 0;

if (!has_error) { // !假 -> 结果为 1 (真)
    printf("操作成功，没有错误。\n");
}

```
