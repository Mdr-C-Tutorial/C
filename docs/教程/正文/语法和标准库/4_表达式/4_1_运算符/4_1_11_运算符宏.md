# 运算符宏

`<iso646.h>` 提供了一组“运算符替代记号宏”，可以用单词形式表示某些符号运算符。它们的历史背景主要是为不便输入特定符号的字符集环境提供兼容写法。

## 1. 对应关系

| 运算符 | 宏       |
| ------ | -------- |
| `&&`   | `and`    |
| `&=`   | `and_eq` |
| `&`    | `bitand` |
| `|`    | `bitor`  |
| `~`    | `compl`  |
| `!`    | `not`    |
| `!=`   | `not_eq` |
| `||`   | `or`     |
| `|=`   | `or_eq`  |
| `^`    | `xor`    |
| `^=`   | `xor_eq` |

这些宏是预处理层替换，不会改变运算符语义和优先级。

## 2. 示例

```c
#include <iso646.h>
#include <stdio.h>

int main(void) {
    int a = 5;
    int b = 10;

    if (a not_eq b and a < b) {
        puts("a < b");
    }
    return 0;
}
```

可能的输出（示例）：

<TerminalWindow>

<输出与输入或平台相关，请以实际运行为准>

</TerminalWindow>


## 3. 使用边界

现代键盘与编译环境通常不再需要这组替代写法，因此多数项目更常使用原生运算符。若代码库决定使用 `<iso646.h>` 记号，建议全仓保持一致，避免同一模块里混用两套风格影响可读性。

## 4. 命名冲突提示

这些名字本质是宏，因此会参与预处理替换。如果项目中把 `and`、`or` 之类名称作为普通标识符，就可能与 `<iso646.h>` 产生冲突。对已有代码库来说，更稳妥的策略通常是统一不引入该头文件，或把使用范围限制在极少数兼容层文件。

## 5. 与“代用记号”章节的关系

`<iso646.h>` 的这些名称属于库宏；而代用记号属于词法层记号规则，两者处于不同层次。阅读时可以把它们分别理解为“库提供的替换入口”和“语言词法兼容入口”，避免把来源混为一谈。

## 6. 迁移与维护建议

若项目已有大量原生运算符写法，不建议只在少量文件局部切到 `<iso646.h>` 风格。风格混杂会增加阅读成本。更稳妥的策略是保持单一风格，必要时只在受限兼容层使用替代记号宏。

## 7. 预处理层替换的边界

因为这组名称是宏，替换发生在预处理阶段。也就是说，它们不会只在“表达式位置”生效，而是会在记号级参与替换。若你在公共头里引入 `<iso646.h>`，再把 `and`、`or` 这类短名字用于其他宏拼接语境，阅读和排错成本都会明显上升。把包含范围收敛到实现文件通常更安全。

## 8. 与代码生成工具协同

部分代码生成器、语法高亮规则或静态检查脚本默认按符号运算符模式匹配。若项目确定使用 `<iso646.h>`，应同步更新这些工具规则，避免出现“源码合法但工具误判”的情况。语义上两者等价，但工具链一致性需要人工维护。
