# 标准库中的宏

在 C 语言编程中，**宏**（preprocessor macros）是确保代码**可移植性**、**安全性**和**可维护性**的核心工具之一。标准库通过一系列头文件定义了大量预定义宏，这些宏提供平台无关的常量、类型别名、数值极限以及格式化说明符，帮助程序员避免硬编码假设，从而让代码在不同架构、编译器和操作系统上行为一致。

本教程将重点介绍C标准库中几组关键宏：

- **`<stddef.h>`**：基础宏，如 ` NULL `、` offsetof `，以及类型 ` size_t `、`ptrdiff_t`（常以宏形式间接使用）。
- **`<stdint.h>`**：固定宽度整数类型（如 ` int32_t `）及其极限宏（如 ` INT32_MAX `、` UINT64_MAX `）。
- **`<inttypes.h>`**：格式化宏（如 ` PRId32 `、` PRIu64 `、` SCNxPTR `），用于`printf`/`scanf`家族的安全跨平台I/O。
- **`<limits.h>`**：基本整数类型的数值极限（如 ` INT_MIN `、` INT_MAX `、` CHAR_BIT `、` LLONG_MAX `）。
- **`<float.h>`**：浮点类型的特性与极限（如 ` FLT_MAX `、` DBL_EPSILON `、` FLT_DIG `）。
- **特征测试宏**：预定义宏如 ` __STDC_VERSION__ `、` __STDC_HOSTED__ `，用于条件编译以适配不同C标准版本（C99、C11、C17、C23）和实现特性。

这些宏大多是**常量表达式**，可在预处理阶段、`#if` 指令或静态断言中使用。掌握它们，不仅能写出更健壮的代码，还能深入理解C语言的底层实现差异。

接下来，我们将逐一详解每个头文件中的宏、其定义目的、使用场景及示例，帮助你从基础到进阶全面运用这些强大工具。

## 1. 为什么优先使用标准宏

标准宏的价值不只是“省事”，更关键的是把平台差异收敛到统一接口。例如，`INT32_MAX` 明确表达“32 位有符号整型上界”，比手写 `2147483647` 更可靠；`PRId64` 明确表达“`int64_t` 的输出格式”，比直接写 `%lld` 更可移植。

这类写法能减少隐式假设：你不需要猜目标平台 `long` 到底是 32 位还是 64 位，也不需要猜不同编译器对格式化长度修饰符的差异。

## 2. 目录与学习顺序

本章建议按“先类型与边界，再格式化与特性检测”的顺序阅读：

1. [12.1 `<stddef.h>`](/教程/正文/语法和标准库/12_标准库中的宏/12_1_stddef)
2. [12.2 `<stdint.h>`](/教程/正文/语法和标准库/12_标准库中的宏/12_2_stdint)
3. [12.3 `<inttypes.h>`](/教程/正文/语法和标准库/12_标准库中的宏/12_3_inttypes)
4. [12.4 `<limits.h>`](/教程/正文/语法和标准库/12_标准库中的宏/12_4_limits)
5. [12.5 `<float.h>`](/教程/正文/语法和标准库/12_标准库中的宏/12_5_float)
6. [12.6 功能特性测试宏](/教程/正文/语法和标准库/12_标准库中的宏/12_6_功能特性测试宏)

## 3. 典型误区

第一类误区是把“实现习惯”当作“标准保证”，例如默认假设 `int` 一定是 32 位。第二类误区是把格式化说明符写死，导致跨平台输出异常。第三类误区是用魔法数字替代标准宏，使代码语义难以审查。

## 4. 使用建议

当代码需要表达“边界”“宽度”“能力前提”时，优先查找并使用标准宏。这样写出来的程序在迁移编译器、升级标准版本时更稳定，也更容易做自动化检查。
