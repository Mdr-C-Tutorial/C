# 派生类型

派生类型是在已有类型之上继续构造出来的类型族，它们不是“附加语法”，而是 C 组织数据和接口的主干。数组描述连续同构对象，指针描述间接访问，结构体与联合体描述复合布局，原子类型描述并发访问下的可见性和一致性。

## 1. 学习顺序

本章按“先布局，再访问，再并发语义”的顺序展开。你可以先看 [7.1 数组](/教程/正文/语法和标准库/7_派生类型/7_1_数组.md) 和 [7.2 指针](/教程/正文/语法和标准库/7_派生类型/7_2_指针.md)，把连续存储和间接寻址建立起来；再看 [7.3 结构体](/教程/正文/语法和标准库/7_派生类型/7_3_结构体.md) 与 [7.4 联合体](/教程/正文/语法和标准库/7_派生类型/7_4_联合体.md)，理解复合对象的布局模型；最后进入 [7.5 原子类型](/教程/正文/语法和标准库/7_派生类型/7_5_原子类型.md)，把单线程语义过渡到并发语义。

## 2. 一段组合示例

```c
#include <stddef.h>

typedef struct {
    int *data;
    size_t size;
} int_vector;
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


这段声明同时使用了结构体、指针和基本整数类型。`data` 指向一段连续整型对象，`size` 描述元素数量。你在项目中看到的绝大多数“容器”接口，都可以还原为这种组合：用一个复合类型承载地址、大小和状态，再围绕它定义操作函数。

## 3. 使用建议

阅读和设计派生类型时，优先回答三个问题：对象的内存形状是否清楚、访问路径是否唯一、生存期是否一致。只要这三点明确，复杂声明会变得可拆解，可维护性也会明显提升。

## 4. 声明阅读的落点

面对复杂声明时，可以按“最里层标识符 + 结合方向”逐步还原：先确定这是对象、函数还是指向它们的指针，再确认数组维度、限定符和返回类型。无论语法多复杂，最后都应落回“这段声明描述了什么对象形状、允许怎样访问”这两个问题。

## 5. 组合类型的接口边界

派生类型经常组合出现，例如“结构体里放指针和长度”“函数返回指针”“数组元素是结构体”。组合本身不是问题，关键是把每个成员的所有权和生命周期说清楚。只要接口把创建、使用、释放边界定义清楚，组合声明也能保持可维护。

## 6. 与对象模型的衔接

派生类型章节和“对象表示、对齐、生存期”章节是互相咬合的：语法描述了形状，对象模型描述了语义边界。阅读派生类型时如果遇到“这段声明是否合法但为什么不安全”，通常就该回到对象表示与生存期规则里做交叉确认。
