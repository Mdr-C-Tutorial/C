# 互斥

互斥量 (Mutex) 用于保证同一时刻只有一个线程进入临界区。它是最常见、最直接的同步原语，适合保护共享对象的一致性。

下文示例基于 `<threads.h>`；若目标工具链未提供该头文件，请把同一思路迁移到平台线程接口。

## 1. 生命周期

互斥量的典型流程是：`mtx_init` 初始化、`mtx_lock` 加锁、`mtx_unlock` 解锁、`mtx_destroy` 销毁。任何一条执行路径只要拿到锁，就必须保证最终释放。

```c
#include <stdio.h>
#include <threads.h>

static mtx_t lock;
static int counter = 0;

int worker(void *arg) {
    (void)arg;
    for (int i = 0; i < 100000; ++i) {
        mtx_lock(&lock);
        counter++;
        mtx_unlock(&lock);
    }
    return 0;
}

int main(void) {
    thrd_t t1, t2;

    if (mtx_init(&lock, mtx_plain) != thrd_success) {
        return 1;
    }

    thrd_create(&t1, worker, NULL);
    thrd_create(&t2, worker, NULL);
    thrd_join(t1, NULL);
    thrd_join(t2, NULL);

    printf("counter = %d\n", counter);
    mtx_destroy(&lock);
    return 0;
}
```

## 2. 易错点

忘记解锁会导致死锁；不同路径上以不一致顺序获取多个锁，会导致循环等待。并发代码出现“偶发卡死”时，首要检查点通常就是锁顺序与异常路径释放策略。

## 3. 实践建议

临界区应尽量短，只放必须受保护的读写；耗时操作放在锁外。这样既减少锁竞争，也降低把系统拖入阻塞链的概率。
