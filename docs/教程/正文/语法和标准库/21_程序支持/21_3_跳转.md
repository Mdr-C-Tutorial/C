# 跳转

除了 `if`、循环和 `goto` 这类结构化控制流，C 标准库还提供了非局部跳转能力：`setjmp` 与 `longjmp`。它们定义在 `<setjmp.h>`，可在深层调用栈中快速回到某个恢复点。

## 1. 基本语义

`setjmp(env)` 会保存当前执行上下文，并返回 `0`；后续若调用 `longjmp(env, value)`，程序会跳回该 `setjmp` 位置，并让 `setjmp` 的返回值变为 `value`（若 `value` 为 `0`，则返回 `1`）。

```c
#include <setjmp.h>
#include <stdio.h>

static jmp_buf env;

void deep_call(void) {
    longjmp(env, 42);
}

int main(void) {
    int code = setjmp(env);
    if (code == 0) {
        deep_call();
    } else {
        printf("recovered: %d\n", code);
    }
    return 0;
}
```

## 2. 适用场景

它适合表达“统一失败回收点”这类机制，例如解释器、解析器或受限环境中的错误回退。若普通 `return` 就能清晰表达控制流，应优先使用普通 `return`，因为可读性更高。

## 3. 关键约束

`longjmp` 只能跳回仍然有效的调用栈上下文；若目标函数已经返回，再跳回去就是未定义行为。另外，`setjmp` 与自动存储期对象的可见值之间存在细节约束，涉及优化与寄存器分配时尤其要谨慎。

## 4. 工程建议

把 `setjmp`/`longjmp` 限定在极小范围，并把资源释放策略写成可复核模板。非局部跳转不是异常系统的完全替代，它是底层工具，适合精确控制，不适合泛化滥用。
