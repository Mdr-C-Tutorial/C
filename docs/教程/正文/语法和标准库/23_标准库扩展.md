# 标准库扩展

C 标准库里有一部分能力属于“可选扩展”或“按实现决定是否提供”的接口。阅读和使用这部分内容时，核心不是记住函数名，而是先做能力探测，再决定是否启用扩展路径。

::: warning 本节可跳过

这些内容在不同工具链上的支持度差异较大，且不少项目不会用到。若当前目标是先掌握主线语法，可以先跳过，后续按需回看。

:::

## 1. Annex K 与 `__STDC_WANT_LIB_EXT1__`

C11 引入了可选的边界检查接口族（常见为 `*_s`）。启用方式通常是在包含相关头文件前定义 `__STDC_WANT_LIB_EXT1__` 为 `1`，然后再通过 `__STDC_LIB_EXT1__` 判断实现是否真的提供了这组接口。

```c
#define __STDC_WANT_LIB_EXT1__ 1
#include <string.h>

#if defined(__STDC_LIB_EXT1__)
/* 可使用 memcpy_s / strcpy_s 等接口 */
#endif
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


## 2. 其他可选能力的探测思路

并发、原子等能力也可能由实现通过特性宏声明缺失，例如 `__STDC_NO_THREADS__`、`__STDC_NO_ATOMICS__`。这类宏的价值在于把“是否支持”前置到编译期，而不是把问题留到运行期。

## 3. 使用建议

扩展能力应当建立在稳定主路径之上：先写纯标准主线，再按收益添加扩展分支，并为不支持扩展的实现保留清晰回退路径。这样既能利用新能力，也能保持移植弹性。

## 4. 一个集中探测模板

扩展宏判断建议集中在统一配置头中，再由业务代码读取结果，避免各模块重复拼装条件分支。

```c
/* config_features.h */
#ifndef CONFIG_FEATURES_H
#define CONFIG_FEATURES_H

#if defined(__STDC_LIB_EXT1__)
#define CFG_HAS_LIB_EXT1 1
#else
#define CFG_HAS_LIB_EXT1 0
#endif

#endif
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


这种组织方式能把“能力探测”与“业务语义”解耦，后续迁移工具链时改动面更小。

## 5. 先定义最小公共子集

面对扩展差异时，一个有效策略是先定义“所有目标平台都可用”的最小能力子集，把它作为默认实现；扩展接口只在该子集之上做可选增强。这样可以让功能边界更稳定，也能让测试覆盖聚焦在真正的差异点上，而不是在主路径里混入大量条件分支。

## 6. 扩展分支应保持接口同形

启用扩展前后，尽量保持对外函数签名、返回语义和错误约定一致，只在内部实现层切换路径。这样调用方就不需要感知“当前是否走扩展实现”，模块耦合也会更低。扩展能力的价值在于增强实现，不在于改变接口形状。

```c
#include <stddef.h>
#include <string.h>

int copy_bytes(void *dst, size_t dst_n, const void *src, size_t src_n) {
#if defined(__STDC_LIB_EXT1__)
    return memcpy_s(dst, dst_n, src, src_n) == 0 ? 0 : -1;
#else
    if (src_n > dst_n) {
        return -1;
    }
    (void)memcpy(dst, src, src_n);
    return 0;
#endif
}
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。


## 7. 迁移时先收敛再替换

工具链升级或目标平台扩展时，建议先把已有扩展判断收敛到统一配置头，再逐步替换底层实现。若在多个业务文件里直接修改条件分支，回归面会迅速扩大。先收敛入口、再替换实现，通常能让迁移过程更可控。

```c
/* feature_switch.h */
#ifndef FEATURE_SWITCH_H
#define FEATURE_SWITCH_H

#if defined(__STDC_LIB_EXT1__)
#define APP_USE_LIB_EXT1 1
#else
#define APP_USE_LIB_EXT1 0
#endif

#endif
```

运行结果：该代码块主要用于语法或结构说明，单独运行通常无终端输出。

